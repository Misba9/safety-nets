<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scroll Triggered Counters</title>
    <style>
 


        .counters-container {
            display: flex;
            justify-content: space-around;
            margin-top: 150vh; /* For testing, place this after some scrolling */
            padding: 50px;
            background-color: #f0f0f0;
        }

        .counter-box {
            text-align: center;
            padding: 20px;
        }

        .counter-box h2 {
            font-size: 40px;
            color: #333;
        }

        .counter-box p {
            font-size: 20px;
            color: #666;
        }
    </style>
</head>
<body>

    <div class="counters-container">
        <div class="counter-box">
            <h2 class="counter" data-target="1423">0+</h2>
            <p>Happy Clients</p>
        </div>
        <div class="counter-box">
            <h2 class="counter" data-target="10">0+</h2>
            <p>Years Experience</p>
        </div>
        <div class="counter-box">
            <h2 class="counter" data-target="1500">0+</h2>
            <p>Projects</p>
        </div>
        <div class="counter-box">
            <h2 class="counter" data-target="28">0+</h2>
            <p>Our Team</p>
        </div>
    </div>

<script>
    const updateCounter = (counter) => {
            const target = +counter.getAttribute('data-target'); // Get the target number from data-target
            const count = +counter.innerText.replace('+', '');   // Get the current number
            const speed = 200;                                   // Adjust the speed of the counting
            const increment = target / speed;                    // Calculate increment

            if (count < target) {
                counter.innerText = `${Math.ceil(count + increment)}+`; // Update counter value
                setTimeout(() => updateCounter(counter), 20);           // Repeat every 20ms
            } else {
                counter.innerText = `${target}+`; // Set the final value
            }
        };

        // IntersectionObserver callback function
        const observerCallback = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const counter = entry.target;           // The observed counter element
                    updateCounter(counter);                 // Start counting when visible
                    observer.unobserve(counter);            // Stop observing this element after counting
                }
            });
        };

        // Create the IntersectionObserver instance
        const observerOptions = {
            threshold: 0.1 // Trigger when 10% of the counter is visible
        };

        const observer = new IntersectionObserver(observerCallback, observerOptions);

        // Observe each counter individually
        const counters = document.querySelectorAll('.counter');
        counters.forEach(counter => {
            observer.observe(counter); // Start observing each counter element
        });
</script>

</body>
</html>
